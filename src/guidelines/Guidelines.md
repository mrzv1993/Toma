# Toma — Project Guidelines

---

# 1. Общие принципы
- Пиши максимально **чистый**, **читаемый** и **минималистичный** код.
- Строго следуй **архитектуре слоёв** (UI → Hooks → State → Services → Data).
- Никакой бизнес-логики в компонентах.
- Никаких inline-стилей (кроме очень редких ситуаций).
- Никаких `any`, `@ts-ignore`, `as unknown`.
- Используй строгую типизацию, все данные должны иметь интерфейсы/типы.
- Код должен быть предсказуемым и легко модифицируемым.
- Каждый компонент — одна ответственность.
- Каждый сервис — одна доменная область.
- Пиши так, будто код будут читать спустя год.

---

# 2. Архитектура проекта

## 2.1. Слои проекта (обязательные)
Проект должен быть структурирован так:

```
src/
  components/        — UI-компоненты без логики
  features/          — функциональные модули
  hooks/             — UI-хуки
  state/             — Zustand-сторы
  services/          — бизнес-логика (PriorityService, SprintService и т.д.)
  repositories/      — доступ к данным Supabase
  utils/             — вспомогательные функции
  types/             — интерфейсы, модели
  constants/
```

## 2.2. Правила по слоям
- **UI-компоненты**: только рендер + вызовы хуков. Никакой логики.
- **Hooks**: хранят логику UI (перемещение, открытие модальных окон, валидаторы).
- **State (Zustand)**: хранит только состояние, никакой доменной логики.
- **Services**: здесь живёт бизнес-логика (таймер, каскады, спринты).
- **Repositories**: только запросы в Supabase.
- **Edge Functions**: только тяжёлые операции.

---

# 3. Работа с Supabase
- Все запросы идут **только через repositories**.
- Никаких запросов из компонентов.
- Все fetch-запросы должны:
  - быть типизированы,
  - иметь обработку ошибок,
  - иметь чёткие интерфейсы DTO.

Типы примерно такие:

```ts
interface TaskDTO {
  id: string;
  title: string;
  description?: string;
  group: number;
  is_completed: boolean;
  min_required_time?: number | null;
  max_allowed_time?: number | null;
}
```

---

# 4. Таймер и интервалы

## 4.1. Принципы
- В любой момент может работать только **один таймер**.
- Переключение задачи = закрытие интервала + начало нового.
- Нельзя запускать таймер для выполненной задачи.
- Нельзя запускать таймер в Inbox.

## 4.2. Оптимизация
- Ререндер 1 раз в секунду только в TimerStore.
- Таймлайн перерисовывается частично.

---

# 5. Drag & Drop правила
- DnD не должен выполнять сетевые запросы во время drag.
- Обновление Supabase только после drop.
- В UI — оптимистичные апдейты.

---

# 6. Priority Cascade (строгая логика)
- Если в группе нет места → задача смещает нижние задачи.
- Если нижняя группа переполнена — каскад вниз.
- Если уровень 1 переполнен — отмена.
- Алгоритм — строго в PriorityService.
- Никакой логики каскада в UI.

---

# 7. Sprint Service
- Завершение спринта:
  - таймер останавливается,
  - создаётся журнал спринта,
  - формируется статистика,
  - создаётся новый спринт,
  - незавершённые задачи переносить в те же группы.
- SprintService должен быть атомарным.

---

# 8. Sprint Preparation Mode

## 8.1. Min Time
Если суммарный минимум задач превышает оставшееся время — разрешены только задачи с Min Time.

## 8.2. Max Time
При достижении лимита:
- задача автоматически завершается,
- таймер блокируется.

---

# 9. Дизайн-система Toma

## 9.1. Общий стиль
- Минимализм.
- Максимальная ясность.
- Чёткие отступы: 8 / 12 / 16 / 24.
- Цвета групп задач — основной цветовой код.
- Ни одного лишнего декоративного элемента.

## 9.2. Типографика
- Шрифт: Inter  
- Базовый размер: 14px  
- Масштаб: 14 / 16 / 18 / 24  

## 9.3. Компоненты shadcn/ui
Использовать обязательно:
- Button
- Input
- Card
- Modal
- Dropdown Menu
- Tabs
- Badge
- ScrollArea
- Separator

## 9.4. Модальные окна и диалоги (КРИТИЧНО!)

### 9.4.1. Ширина модальных окон
Всегда используй адекватные размеры для модальных окон:
- **Маленькие диалоги** (подтверждения, простые формы): `max-w-md` (448px)
- **Средние диалоги** (формы с несколькими полями): `max-w-lg` (512px) или `max-w-xl` (576px)
- **Большие диалоги** (списки, таблицы, комплексные формы): `max-w-2xl` (672px) или `max-w-3xl` (768px)
- **Очень большие диалоги** (редакторы, детальные просмотры): `max-w-4xl` (896px) или `max-w-5xl` (1024px)

**ЗАПРЕЩЕНО:**
- Использовать слишком узкие окна, где кнопки не помещаются
- Игнорировать содержимое при выборе ширины
- Использовать фиксированную ширину без `max-w-*`

### 9.4.2. Структура модального окна
Обязательная структура:
```tsx
<Dialog/AlertDialog open={isOpen} onOpenChange={handleOpenChange}>
  <DialogContent className="max-w-[размер] bg-[var(--color-surface)] border-[var(--color-border)]">
    <DialogHeader>
      <DialogTitle className="text-[var(--color-text-primary)]">
        Заголовок
      </DialogTitle>
      <DialogDescription className="text-[var(--color-text-secondary)]">
        Описание
      </DialogDescription>
    </DialogHeader>
    
    {/* Основной контент с ScrollArea если нужно */}
    <div className="space-y-4">
      {/* Контент */}
    </div>
    
    <DialogFooter>
      <Button variant="outline">Отмена</Button>
      <Button>Действие</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

### 9.4.3. Прокрутка в модальных окнах
- Если контент может быть длинным — используй `<ScrollArea className="max-h-[400px]">` 
- Всегда добавляй `pr-4` к контенту внутри ScrollArea для отступа от скроллбара
- Заголовок и футер должны быть зафиксированы (не скроллиться)

### 9.4.4. Цвета и стили
Всегда используй CSS-переменные для модальных окон:
- Фон: `bg-[var(--color-surface)]`
- Бордер: `border-[var(--color-border)]`
- Заголовок: `text-[var(--color-text-primary)]`
- Описание: `text-[var(--color-text-secondary)]`
- Ховер: `hover:bg-[var(--color-surface-hover)]`

### 9.4.5. Кнопки в футере
- Кнопка отмены: `variant="outline"` или стили вручную с `bg-[var(--color-surface-hover)]`
- Основная кнопка: `bg-[var(--color-primary)]` с `hover:bg-[var(--color-primary-hover)]`
- Деструктивная кнопка: `bg-red-500` с `hover:bg-red-600`
- Всегда добавляй `disabled` состояние при загрузке

### 9.4.6. Адаптивность
- Модальные окна должны корректно работать на мобильных устройствах
- На маленьких экранах: `max-w-[calc(100vw-2rem)]` для отступов по бокам
- Используй `sm:max-w-lg md:max-w-2xl` для адаптивной ширины

---

# 10. Правила написания кода

## 10.1. Именование
- Файлы: `kebab-case.tsx`
- Компоненты: `PascalCase`
- Хуки: `useCamelCase`
- Типы: `PascalCase`
- Переменные: `camelCase`

## 10.2. Файловая структура
Каждый компонент = один файл + один SCSS/TSX блок стилей.

## 10.3. Форматирование
- 120 символов в строке максимум.
- Один компонент на файл.
- В начале файла — интерфейсы, потом компонент.

---

# 11. UI Guidelines (Toma)

## 11.1. Четыре колонки
- Hooks  
- Inbox  
- Sprint  
- Timeline  

Каждая должна соответствовать:
- минимализму,
- аккуратному layout-у,
- понятной визуальной иерархии.

## 11.2. Карточка задачи
Минимальная:
- название  
- время выполнено  
- история  
- сотрудник (в будущем)  

Без лишнего.

---

# 12. Git и версия кода
- Один PR = одна фича.
- Не смешивать UI и backend.
- Коммиты — в формате:

```
feat: добавил логику Max Time
fix: исправил каскад уровня 8
refactor: вынес PriorityService
```

---

# 13. Принципы Toma (философия разработки)
- Простота = сила.
- Решение должно быть очевидным.
- Не добавляй ничего лишнего.
- Всегда думай: “Как это упростить?”.
- Каждый день должен приближать к цели.
- Твой код должен помогать правильно проживать день.

---

# 14. Ограничения
- Не изменять схему Supabase.
- Не использовать сторонние UI-библиотеки.
- Не создавать новые абстракции без необходимости.
- Не использовать классовые компоненты.

---

# 15. Обязательные требования
- Код компилируется.
- Нет ошибок TS.
- Нет dead code.
- Код покрыт комментариями только там, где сложно.
- Архитектура слоёв соблюдена.
- Все сервисы изолированы.
- Логика таймера и каскада работает строго по правилам.

---

# 16. Если ИИ сомневается
- Выбирай **простой вариант**.
- Используй **минимум зависимостей**.
- Следуй **архитектурным слоям**.
- Не меняй существующую структуру без крайней необходимости.

---

# Конец файла